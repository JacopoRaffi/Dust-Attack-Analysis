\chapter{Background}
In questo capitolo verrà descritta la tecnologia alla base di Bitcoin. Particolare attenzione verrà data alla blockchain, la struttura dati che costituisce il libro contabile, al funzionamento delle transazioni, agli indirizzi per esporre infine la questione relativa all'anonimato. 
%1- Spiegare cosa sono i btcoin("storia" ecc...)
%2- Spiegare la blockchain(definizione)
%3- Spiegare address, wallet(anonimato), generazione indirizzi
%4- concentrarsi sulle transazioni(differenza teoria e pratica anonimato), come avvengono come funzionano %la fee ecc...
%Ricorda di mettere immagini
\section{Bitcoin}
Bitcoin, l’unità monetaria elettronica a cui facciamo riferimento in questa tesi, è stata sviluppata da Satoshi Nakamoto, un misterioso autore giapponese la cui identità resta a tutt'oggi ignota, tanto da indurre molti a pensare che si tratti di uno pseudonimo, o che dietro a tale nome si celi in realtà non una singola persona, ma addirittura un gruppo di ricercatori o di informatici. L’articolo in cui viene presentato l’intero protocollo Bitcoin viene pubblicato nel 2008, sotto il nome di ”Bitcoin: A Peer-to-Peer Electronic Cash System”\cite{nakamoto2009bitcoin}; il paper è facilmente reperibile e contiene la descrizione dettagliata del protocollo alla base del funzionamento di Bitcoin.\\La peculiarità di tale sistema è l’uso di una rete secondo il modello Peer-to-Peer per effettuare, diffondere e validare le transazioni, e l’intero storico di esse viene mantenuto in un libro contabile distribuito e di pubblica consultazione. La grande e difficile sfida che Bitcoin dunque si pone è quella di coniugare l’anonimato degli utenti con un’alta affidabilità relativamente alle transazioni e alla loro validità e integrità.\\A fronte della sfida di trasparenza versus affidabilità, è fondamentale definire un’implementazione del libro contabile che impedisca alterazioni di transazioni già registrate e validate: ricordiamo che in questo contesto paritario e distribuito, nessun controllo viene effettuato da parte di entità centrali, come per esempio le banche.\\
La soluzione ideata da Nakamoto per garantire l’integrità dello storico delle transazioni è stata quella di implementare il libro contabile tramite una particolare struttura dati: la blockchain.\\Come suggerisce il nome, la struttura si compone di una serie di blocchi collegati tra di loro come in una catena: ogni blocco racchiude un insieme di transazioni effettuate in un certo periodo temporale.\\Il blocco corrente, non ancora inserito, contiene le ultime transazioni la cui legittimazione deve essere ancora approvata, mentre i blocchi precedenti, già
agganciati alla catena, si riferiscono a transazioni già validate, e la blockchain è fin lì immutabile. Il meccanismo che garantisce la totale immutabilità della struttura, pena la sua completa invalidazione, è la crittografia.\\\\
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{Images/blockChaining.pdf}
    \caption{Schema della Blockchain}
    \label{fig:blockchain}
\end{figure}
\FloatBarrier
\section{Blockchain}
Un generico blocco Bi all’interno della blockchain contiene la sequenza di transazioni relative ad un certo periodo temporale (supponiamo che siano n: T1 , T2 , ... ,Tn ) e un valore hash $h_{i-1}$ identificativo del blocco precedente nella catena, che è l’output di una funzione hash crittografica (la cui definizione sarà data nel seguito).\\È inoltre presente un campo detto nonce, che servirà per l’operazione di mining, ovvero il procedimento che porta all’aggiunta di un nuovo blocco alla blockchain. Sono presenti anche altri dati all’interno del blocco, ma al fine di descrivere il meccanismo crittografico che salvaguarda l’integrità della struttura questo livello di dettaglio è sufficiente.\\\\\\In Figura \ref{fig:blocchi} è rappresentata la struttura di un generico blocco Bi all’interno della blockchain.
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.4, trim = 0cm 0cm 0cm 3cm, clip]{Images/blocco_singolo.pdf}
    \caption{Schema di un generico blocco}
    \label{fig:blocchi}
\end{figure}
\FloatBarrier
Come accennato sopra, ogni blocco ha un suo identificativo univoco, una sor-
ta di impronta digitale personale, che è l’output di una opportuna funzione
hash.\\
Una funzione hash $f$: X $\longrightarrow$ Y è una funzione matematica avente come dominio X e codominio Y, insiemi finiti tali che $|X| >> |Y |$.\\Tale funzione prende in input elementi di X di lunghezza qualsiasi e produce in output, a prescindere dalla lunghezza dell’input, stringhe binarie di dimensione fissa, i cosiddetti fingerprint, chiamati anche immagini hash o semplicemente hash.\\
Una proprietà fondamentale delle funzioni hash è relativa al tempo necessario al loro calcolo: devono essere calcolate efficientemente, ossia a fronte di un input di $m$ bit, la complessità computazionale per produrne il fingerprint deve essere $O(m)$, lineare o comunque polinomiale nei bit su cui è rappresentato l’input.\\ Vista la grande differenza di cardinalità tra i due insiemi X e Y, inevitabilmente alcuni input diversi della funzione hash avranno la stessa immagine; questo fenomeno è detto collisione: $x_1$ e $x_2$ $\in$ X, con $x_1 \neq x2$ , collidono se la loro immagine hash è la stessa ( f ($x_1$ ) = f ($x_2$ ) ).\\In crittografia si usano alcune famiglie di funzioni hash molto particolari, dette funzioni hash one-way o funzioni hash crittografiche, le quali devono rispettare altre importanti proprietà oltre a quelle descritte sopra:
\begin{enumerate}
    \item \textbf{Proprietà di one-way}: dato y $\in$ Y, output della funzione f, deve essere computazionalmente difficile invertire la funzione, ossia trovare un x $\in$ X tale che f (x) = y. Il termine one-way significa proprio questo: una funzione hash ”facile” da calcolare (complessità polinomiale nel numero di bit dell’input) ma ”difficile” da invertire (complessità esponenziale, il che rende l’inversione inattuabile all’atto pratico).
    \item \textbf{Proprietà di claw-free}: Per la funzione f , deve essere computazionalmente difficile determinare due elementi $x_1$ e $x_2 \in$ X ($x_1 \neq x_2$) tali che f ($x_1$ ) = f ($x_2$). Ciò significa che per una funzione hash crittografica non deve essere possibile trovare due elementi che collidono in tempo ragionevole.
\end{enumerate}
Un insieme di funzioni hash crittografiche ampiamente usate è quello delle SHA (Secure Hash Algorithm). Una di queste è la SHA-256, funzione hash crittografica che da input di dimensioni variabili produce un fingerprint della lunghezza fissa di 256 bit, ed è la funzione utilizzata per calcolare gli hash dei blocchi all’interno della blockchain.\\L’immagine hash del blocco $B_i$ è calcolata applicando la SHA-256 all’input formato dalla concatenazione delle transazioni lì contenute con il nonce e l’hash del blocco precedente, come riassunto dalla seguente formula (H è una funzione hash crittografica, in genere la SHA-256, e il simbolo $||$ è l’operatore di concatenazione):
\begin{center}
    $hash(B_i) = H(T_1||T_2||...||T_n||hash(B_{i-1})||nonce)$
\end{center}
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.5, trim = 1cm 4cm 0cm 4cm, clip]{Images/blocchi_sha.pdf}
    \caption{Calcolo hash blocco $B_i$}
    \label{fig:sha-256}
\end{figure}
\FloatBarrier
Mentre le transazioni, e quindi anche la loro concatenazione, sono note nel blocco, così come è noto l’hash proveniente dal blocco precedente, il valore del nonce è incognito. L’attività di mining consiste nel risolvere un puzzle crittografico: trovare il valore del nonce tale che l’immagine hash prodotta dalla SHA-256 inizi esattamente con $t$ zeri, dove $t$ è un valore prefissato dal sistema, e variabile nel tempo.\\
La ricerca del nonce per la corretta aggiunta di un blocca è denominata \textbf{Proof of work}. L'unico modo per di trovare il nonce che produca un fingerprint che inizi con $t$ zeri, è quello di applicare ripetutamente la funzione SHA-256 con nonce via via diversi, finchè non si giunge ad un hash che soddisfa la proprietà desiderata. La risoluzione del problema è esponenziale in $t$, infatti la ricerca del nonce richiede tempo $O(2^t)$, ciò rende il problema di difficile risoluzione, in quanto è necessario far eseguire una lunga serie di calcoli alle macchine; nella pratica i calcolatori sono stati ottimizzati a livello hardware con lo scopo di calcolare il più rapidamente possibile la funzione SHA-256. Il valore di t viene aggiornato periodicamente dal sistema, in modo che la validazione di un blocco richieda sempre in media circa 10/15 minuti di tempo.\\Questo sistema evita che i blocchi già inseriti possano essere modificati retroattivamente: cambiando il contenuto di un blocco, ne cambierebbe anche il valore hash, e ciò implica il dover ricalcolare tutti i nonce dei blocchi successivi ad esso, perchè altrimenti le immagini hash non corrisponderebbero più tra blocchi consecutivi; dunque ciò che è stato scritto sulla blockchain è da considerarsi immutabile, a meno di rendere inconsistente tutta la struttura anche alterandone una sola transazione.\\I miner, ossia i nodi della rete che dispongono di calcolatori potenti abbastanza da risolvere le Proof of Work, rappresentano di fatto gli unici a poter avere il diritto di aggiungere transazioni alla blockchain, e nel farlo consumano un gran quantitativo di energia e di risorse di calcolo; per questo, il primo nodo di mining che riesce ad agganciare correttamente un blocco alla blockchain riceve un premio in bitcoin, nella forma di una transazione priva di input e con output l’address del miner: la \textbf{coinbase}, registrata anch’essa nella blockchain come una normale transazione. Il premio, di 25 bitcoin nel 2014, sarà dimezzato approssimativamente ogni quattro anni per essere deﬁnitivamente azzerato nel 2140 quando il numero complessivo di bitcoin esistenti dovrebbe raggiungere 21 milioni.
\section{Transazioni e Address in Bitcoin}
In questo  paragrafo verranno approfonditi i concetti stessi di transazione e di address, descrivendo con un grado di dettaglio funzionale ai nostri scopi il protocollo di pagamento e, anche in questo caso, la crittografia che vi sta dietro, sia per la diffusione delle transazioni che per la cifratura degli address.\\I software cliente di bitcoin, per esempio Bitcoin Core,, sono caricato sul PC o sullo smartphone di ogni utente A e genera anzitutto una coppia di chiavi privata-pubblica $k_A [prv]$, $k_A [pub]$ per un cifrario asimmetrico su curve ellittiche. La
chiave privata $k_A [prv]$ è ovviamente nota solo ad A e, come vedremo in seguito, è utilizzata da esso per ﬁrmare le transazioni che genera e diﬀonde sulla rete. La chiave pubblica $k_A [pub]$ è utilizzata per controllare la ﬁrma di A ed è anche impiegata come suo identiﬁcatore: a tale scopo viene trasformata attraverso applicazioni ripetute della funzione hash SHA-256 (immagine a 256 bit), per essere poi compressa via RIPEMD-160 in un’immagine di 160 bit in testa alla quale è aggiunta una speciale sequenza che indica che la stringa complessiva è di fatto un indirizzo bitcoin.
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.5, trim = 1cm 2cm 0cm 2cm, clip]{Images/address_gen.pdf}
    \caption{Generazione address in Bitcoin}
    \label{fig:sha-256_address}
\end{figure}
\FloatBarrier
Gli address in Bitcoin si presentano come stringhe alfanumeriche di questo tipo: 1BAFWQhH9pNkz3mZDQ1tWrtKkSHVCkc3fV.\\Come già osservato questo indirizzo non corrisponde a una “locazione” dell'utente ma a un modo per identiﬁcarlo, sia per potergli dirigere una transazione che per controllare che possieda eﬀettivamente i fondi che pretende di spendere. Oltre a creare le chiavi e gli indirizzi il software cliente permette di costruire le transazioni. L'insieme delle coppie chiave pubblica-privata è contenuto all'interno di un apposito wallet, ad ognuna di queste coppie è associata un indirizzo però nessuno è a conoscenza del fatto che questi indirizzi appartengano allo stesso wallet. Questo è importante perchè così è possibile tracciare l'attività dei singoli address ma non l'attività di un intero wallet, garantendo un maggiore anonimato. Una transazione in bitcoin ha la forma “il pagatore A vuole inviare X bitcoin al ricevente B”, completata dalla ﬁrma digitale di A. Si noti che A e B sono indicati attraverso i loro indirizzi bitcoin e la transazione viene inviata per broadcast a tutti gli utenti. Diversamente da ogni altra forma di transazione economica, il ricevente B non ha la garanzia che la transazione sia valida ﬁnché, come vedremo, essa non è convalidata dalla rete. In eﬀetti B sarebbe in grado di veriﬁcare sia la ﬁrma di A che i fondi che A ha a disposizione, poiché la chiave pubblica di A è nota e tutte le transazioni eseguite sulla rete sono pubbliche, ma non ha il tempo di veriﬁcare che A non abbia utilizzato gli stessi fondi in istanti immediatamente precedenti per pagamenti diversi. Formalmente una transazione è innescata secondo il seguente schema:
\begin{center}
\textbf{Protocollo di transazione Bitcoin}:
\begin{enumerate}
    \item L’utente A genera un messaggio m = $adr_A$ $-$ X $-$ $adr_B$ , dove $adr_A$ , $adr_B$ sono gli indirizzi Bitcoin di A e B, e X è la somma da trasferire da A a B.
    \item L’utente A calcola l’hash $h = SHA-256(m)$ del messaggio e genera la ﬁrma $f = D(h, k_A [prv])$ per m.
    \item La coppia $<m, f>$ viene diffusa in broadcast da A sulla rete.
    \item L’utente B attende che la rete convalidi la transazione prima di accettarla.
\end{enumerate}
\end{center}
La chiave privata è l’unico documento valido per dimostrare la proprietà in bitcoin di un utente A.
La perdita della chiave comporta la perdita della proprietà a causa dell’impossibilità di ﬁrmare transazioni, e il furto della chiave da parte di un truﬀatore che la usi per ﬁrmare al posto di A comporta anch’esso la perdita di proprietà.\\Un address acquisisce valore in base a quanti bitcoin detiene; quando si usa un address per pagare bitcoin (come input di una transazione), il suo valore viene azzerato, non è possibile spendere solo parte dei bitcoin che costituiscono il valore dell’address. Se un address A paga X bitcoin ad un address B, dopo la transazione il valore di A sarà azzerato, mentre il valore di B aumenterà di X bitcoin. In caso di eventuale resto, nel wallet del pagante si creerà un \textbf{change address}, che acquisirà un valore pari al resto ricevuto. Il change address può essere un address diverso da A, oppure A stesso, a discrezione dell’utente: per rafforzare l’anonimato è estremamente consigliabile da parte del pagante, al fine di ricevere i resti, utilizzare sempre address diversi da quelli usati per effettuare il pagamento.
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.4, trim = 1cm 2cm 0cm 3cm, clip]{Images/Transactions-input-and-output-in-blockchain.jpg.pdf}
    \caption{Schema transazioni in Bitcoin}
    \label{fig:transaction}
\end{figure}
\FloatBarrier
Una transazione in generale può essere multi-input e multi output: sono presenti quindi più address paganti e/o più address riceventi, generalmente l'importo totale di input non viene speso in output ma parte di esso viene dato ai miners come fee. Formalmente la fee, raccolta dai miners come ricompensa per includere la transazione in un blocco, è definita come:
\begin{center}
    $fee = \sum_{inputs} importo(input_i) - \sum_{outputs} importo(output_i)$
\end{center}
Le transazioni in realtà sono molto più complesse di come le ho descritte precedentemente, non contengono solo valori come address e importo ma includono anche del codice, in particolare ogni transazione comprende anche degli script. Bitcoin utilizza un sistema di script Forth-like, basato su stack e non Turing-completo; questa scelta di evitare i loop è intenzionale in quanto impedisce possibili cicli infiniti.
\section{Anonimato in Bitcoin}


